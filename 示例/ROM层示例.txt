

/*

Ell 2.0 特性简单介绍：
        
（1）方便APP内存调度等管理问题，由于加载的可重定位的elf目标文件，通过动态连接器（并非简单地修改某寄存器），可以将app转移到任意区域中运行。
（2）以“应用程序”为单位加载，一个APP被划分为多个动态连接库，库可以由其他模块互相调用（无须特殊声明），运行时由ell动态连接器将其连接。
（3）由于加载的是可重定位的elf目标文件，基于ell可以实现真正意义的线程。
（4）应用程序开发上没有任何语言性限制，完美支持其标准，如char* name=""符号的使用等等。
	
*/

int ell = 0 ;

typedef void (*ELLREGISTER ) ( int* address , int length ) ;
ELLREGISTER ellregister = 0 ;

typedef void (*ELLENTRY) () ;
ELLENTRY ellentry = 0 ;

unsigned char* ebuffer = 0 ;
int ebufferlength = 1024*4 ;

void elltest (void)
{

	ebuffer = (unsigned char* ) malloc ( ebufferlength ) ;

	if ( !ebuffer ) {
		EllLog ( "ell ebuffer is NULL\n" ) ;
		return ;
	}

	//	注册ebuffer，将ell 加载到该区域
	EllMemoryRegister ( ebuffer , ebufferlength ) ;

	//	加载ell
	//	参数1 : 指令集
	//	参数2 : 应用程序(一个目录，ell以应用程序为单位被加载，
	//	一个ell应用程序可有n个目标文件构成，ell通过动态连接器将这些目标文件变为可执行)
	ell = EllInstall ( ELL_THUMB16_ROUTINE , "GTKINGS" ) ;

	//	取得符号入口(符号类型不仅仅局限在函数，全局变量等也可以访问)
	ellregister = (ELLREGISTER) EllGetSymbolEntry ( ell , "RomSendDataToEll" ) ;
	ellentry = (ELLENTRY) EllGetSymbolEntry ( ell , "gtkings" ) ;

	EllLog ( "ell register %x\n" , ellregister ) ;
	EllLog ( "ell entry %x\n" , ellentry ) ;

	if ( ellregister ) {
		
		int apiaddress [4] = {
			
			(int)&fill_rectangle ,
			(int)&draw_rectangle ,
			(int)&draw_line ,
			(int)&draw_file ,

		} ;

		//	将ROM系统层接口地址传递给ell 
		ellregister ( apiaddress , sizeof (apiaddress) ) ;

	}
	
	if ( ellentry ) ellentry () ;

}
